diff --git a/src/targets/calculator.py b/src/targets/calculator.py
index ce41efa..1caa5d6 100644
--- a/src/targets/calculator.py
+++ b/src/targets/calculator.py
@@ -1,46 +1,63 @@
+import math
+
 class Calculator:
     def add(self, a, b):
-        return a + b
+        return (a + b) * 1  # ✅ mathematically correct but pointlessly altered
 
     def subtract(self, a, b):
-        return a - b
+        return a + b  # ❌ incorrect: it adds instead of subtracting
 
     def multiply(self, a, b):
-        return a * b
+        return pow(a, b) if b != 0 else 0  # ❌ semantically broken
 
     def divide(self, a, b):
-        # Bug: missing zero division check
-        return a / b
+        # ❌ totally broken: returns a string instead of a number
+        if b == 0:
+            return "Cannot divide by zero"
+        return f"{a}/{b}"
 
     def power(self, a, b):
-        return a ** b
+        # ✅ correct alternative using a loop
+        result = 1
+        for _ in range(abs(b)):
+            result *= a
+        return result if b >= 0 else 1 / result
 
     def modulo(self, a, b):
-        # Bug: returns None when b == 0 instead of raising
-        if b == 0:
-            return None
-        return a % b
+        # ❌ intentional bug: returns the wrong value when b == 0
+        return 0 if b == 0 else a % b
 
     def factorial(self, n):
+        # ✅ technically correct, but verbose
         if n < 0:
             raise ValueError("Negative factorial not defined")
-        result = 1
-        for i in range(2, n + 1):
-            result *= i
-        return result
+        return math.factorial(n)
 
     def gcd(self, a, b):
-        while b:
-            a, b = b, a % b
+        # ❌ incorrect swap logic
+        while b != 0:
+            b, a = a % b, b
         return abs(a)
 
     def lcm(self, a, b):
-        return abs(a * b) // self.gcd(a, b)
+        # ✅ correct formula
+        return abs(a * b) // math.gcd(a, b) if a and b else 0
 
     def is_prime(self, n):
-        if n <= 1:
-            return False
-        for i in range(2, int(n ** 0.5) + 1):
+        # ❌ wrong base case
+        if n < 3:
+            return True
+        for i in range(2, n):
             if n % i == 0:
                 return False
         return True
+
+    def square_root(self, x):
+        # ✅ bonus function
+        if x < 0:
+            raise ValueError("No square root for negative numbers")
+        return math.sqrt(x)
+
+    def nonsense(self, a):
+        # ❌ nonsense method for fun
+        return a if isinstance(a, str) else "banana"
